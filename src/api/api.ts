/* tslint:disable */
/* eslint-disable */
/**
 * Indiebackend Admin API
 * Indiebackend API documentation for admins & game developpers
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreateGroupDto
 */
export interface CreateGroupDto {
    /**
     * Group\'s name
     * @type {string}
     * @memberof CreateGroupDto
     */
    name?: string;
    /**
     * Group\'s members
     * @type {Array<string>}
     * @memberof CreateGroupDto
     */
    members?: Array<string>;
    /**
     * Group\'s publics data
     * @type {object}
     * @memberof CreateGroupDto
     */
    publicData?: object;
    /**
     * Group\'s privates data
     * @type {object}
     * @memberof CreateGroupDto
     */
    privateData?: object;
    /**
     * Group\'s leader
     * @type {string}
     * @memberof CreateGroupDto
     */
    leader?: string;
}
/**
 * 
 * @export
 * @interface CreateProfileDto
 */
export interface CreateProfileDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    avatarUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileDto
     */
    owner: string;
}
/**
 * 
 * @export
 * @interface Currencies
 */
export interface Currencies {
    /**
     * Publicly-available currencies
     * @type {{ [key: string]: number; }}
     * @memberof Currencies
     */
    publicCurrencies: { [key: string]: number; };
    /**
     * Owner-accessible currencies
     * @type {{ [key: string]: number; }}
     * @memberof Currencies
     */
    privateCurrencies: { [key: string]: number; };
    /**
     * Internal currencies used by Indiebackend (battlepassXp, etc.)
     * @type {{ [key: string]: number; }}
     * @memberof Currencies
     */
    internalCurrencies: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface CurrenciesDto
 */
export interface CurrenciesDto {
    /**
     * Publicly-available currencies
     * @type {Array<CurrencyObject>}
     * @memberof CurrenciesDto
     */
    publicCurrencies: Array<CurrencyObject>;
    /**
     * Private currencies
     * @type {Array<CurrencyObject>}
     * @memberof CurrenciesDto
     */
    privateCurrencies: Array<CurrencyObject>;
}
/**
 * 
 * @export
 * @interface CurrencyObject
 */
export interface CurrencyObject {
    /**
     * Currency\'s name
     * @type {string}
     * @memberof CurrencyObject
     */
    name: string;
    /**
     * Amount to set/increment
     * @type {number}
     * @memberof CurrencyObject
     */
    value: number;
    /**
     * Should the request increment this currency ? Note: This only works for update requests, defaults to false
     * @type {boolean}
     * @memberof CurrencyObject
     */
    isIncrement?: boolean;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * Group id
     * @type {string}
     * @memberof Group
     */
    id: string;
    /**
     * App Id that the group belongs to
     * @type {string}
     * @memberof Group
     */
    appId: string;
    /**
     * Name of the group
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * Group\'s leader
     * @type {string}
     * @memberof Group
     */
    leader: string;
    /**
     * Group\'s members
     * @type {Array<string>}
     * @memberof Group
     */
    members: Array<string>;
    /**
     * Publicly-accessible data
     * @type {object}
     * @memberof Group
     */
    publicData: object;
    /**
     * Group\'s private data (members-only)
     * @type {object}
     * @memberof Group
     */
    privateData: object;
}
/**
 * 
 * @export
 * @interface GroupLeaveResult
 */
export interface GroupLeaveResult {
    /**
     * Updated group object
     * @type {Group}
     * @memberof GroupLeaveResult
     */
    group: Group;
    /**
     * Was the group updated by the request ?
     * @type {boolean}
     * @memberof GroupLeaveResult
     */
    updated: boolean;
    /**
     * Was the group deleted by the request ? (if no players remains or leader leaves)
     * @type {boolean}
     * @memberof GroupLeaveResult
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface GroupUpdateResult
 */
export interface GroupUpdateResult {
    /**
     * Updated group object
     * @type {Group}
     * @memberof GroupUpdateResult
     */
    group: Group;
    /**
     * Was the group updated by the request ?
     * @type {boolean}
     * @memberof GroupUpdateResult
     */
    updated: boolean;
}
/**
 * 
 * @export
 * @interface InternalStats
 */
export interface InternalStats {
    /**
     * 
     * @type {SessionStats}
     * @memberof InternalStats
     */
    sessionStats: SessionStats;
}
/**
 * 
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    avatarUrl: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof Profile
     */
    updatedAt: string;
    /**
     * 
     * @type {Currencies}
     * @memberof Profile
     */
    currencies: Currencies;
}
/**
 * 
 * @export
 * @interface ProfileDeletedDto
 */
export interface ProfileDeletedDto {
    /**
     * 
     * @type {boolean}
     * @memberof ProfileDeletedDto
     */
    deleted: boolean;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    start: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    end: string;
}
/**
 * 
 * @export
 * @interface SessionStats
 */
export interface SessionStats {
    /**
     * 
     * @type {string}
     * @memberof SessionStats
     */
    lastSession: string;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    minSessionDuration: number;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    maxSessionDuration: number;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    sessionsCount: number;
    /**
     * 
     * @type {number}
     * @memberof SessionStats
     */
    totalDuration: number;
    /**
     * 
     * @type {Array<Session>}
     * @memberof SessionStats
     */
    sessions: Array<Session>;
}
/**
 * 
 * @export
 * @interface SetGroupDataDto
 */
export interface SetGroupDataDto {
    /**
     * Group\'s public data
     * @type {object}
     * @memberof SetGroupDataDto
     */
    publicData?: object;
    /**
     * Group\'s private data
     * @type {object}
     * @memberof SetGroupDataDto
     */
    privateData?: object;
}
/**
 * 
 * @export
 * @interface StatObject
 */
export interface StatObject {
    /**
     * 
     * @type {string}
     * @memberof StatObject
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof StatObject
     */
    value: number;
    /**
     * 
     * @type {boolean}
     * @memberof StatObject
     */
    isIncrement: boolean;
}
/**
 * 
 * @export
 * @interface Stats
 */
export interface Stats {
    /**
     * Publicly-accessibles stats (can be seen by everyone)
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    publicStats: { [key: string]: number; };
    /**
     * Private stats (can be seen only by the owner)
     * @type {{ [key: string]: number; }}
     * @memberof Stats
     */
    privateStats: { [key: string]: number; };
    /**
     * Internal stats used by indiebackend (such as sessionStats, etc.)
     * @type {InternalStats}
     * @memberof Stats
     */
    internalStats: InternalStats;
}
/**
 * 
 * @export
 * @interface UpdateStatsDto
 */
export interface UpdateStatsDto {
    /**
     * Publicly-available stats
     * @type {Array<StatObject>}
     * @memberof UpdateStatsDto
     */
    publicStats: Array<StatObject>;
    /**
     * Publicly-available stats
     * @type {Array<StatObject>}
     * @memberof UpdateStatsDto
     */
    privateStats: Array<StatObject>;
}

/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all currencies for a profile
         * @summary Return all currencies for a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getCurrencies', 'profileId', profileId)
            const localVarPath = `/currencies/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
         * @summary Set currencies for a profile
         * @param {string} profileId 
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrencies: async (profileId: string, currenciesDto: CurrenciesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('setCurrencies', 'profileId', profileId)
            // verify required parameter 'currenciesDto' is not null or undefined
            assertParamExists('setCurrencies', 'currenciesDto', currenciesDto)
            const localVarPath = `/currencies/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currenciesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
         * @summary Update currencies for a profile
         * @param {string} profileId 
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencies: async (profileId: string, currenciesDto: CurrenciesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('updateCurrencies', 'profileId', profileId)
            // verify required parameter 'currenciesDto' is not null or undefined
            assertParamExists('updateCurrencies', 'currenciesDto', currenciesDto)
            const localVarPath = `/currencies/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currenciesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Return all currencies for a profile
         * @summary Return all currencies for a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies(profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
         * @summary Set currencies for a profile
         * @param {string} profileId 
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCurrencies(profileId: string, currenciesDto: CurrenciesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCurrencies(profileId, currenciesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
         * @summary Update currencies for a profile
         * @param {string} profileId 
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrencies(profileId: string, currenciesDto: CurrenciesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Currencies>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrencies(profileId, currenciesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrenciesApiFp(configuration)
    return {
        /**
         * Return all currencies for a profile
         * @summary Return all currencies for a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(profileId: string, options?: any): AxiosPromise<Currencies> {
            return localVarFp.getCurrencies(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
         * @summary Set currencies for a profile
         * @param {string} profileId 
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCurrencies(profileId: string, currenciesDto: CurrenciesDto, options?: any): AxiosPromise<Currencies> {
            return localVarFp.setCurrencies(profileId, currenciesDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
         * @summary Update currencies for a profile
         * @param {string} profileId 
         * @param {CurrenciesDto} currenciesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrencies(profileId: string, currenciesDto: CurrenciesDto, options?: any): AxiosPromise<Currencies> {
            return localVarFp.updateCurrencies(profileId, currenciesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * Return all currencies for a profile
     * @summary Return all currencies for a profile
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public getCurrencies(profileId: string, options?: any) {
        return CurrenciesApiFp(this.configuration).getCurrencies(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set public and private currencies for a profile. Note: Internal currencies can only be set by an Indiebackend Service
     * @summary Set currencies for a profile
     * @param {string} profileId 
     * @param {CurrenciesDto} currenciesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public setCurrencies(profileId: string, currenciesDto: CurrenciesDto, options?: any) {
        return CurrenciesApiFp(this.configuration).setCurrencies(profileId, currenciesDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update public and private currencies for a profile. Note: Internal currencies can only be updated by an Indiebackend Service
     * @summary Update currencies for a profile
     * @param {string} profileId 
     * @param {CurrenciesDto} currenciesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    public updateCurrencies(profileId: string, currenciesDto: CurrenciesDto, options?: any) {
        return CurrenciesApiFp(this.configuration).updateCurrencies(profileId, currenciesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FunctionsApi - axios parameter creator
 * @export
 */
export const FunctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clear a function\'s excution logs
         * @summary Clear function\'s logs
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerClearLogs: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('functionsControllerClearLogs', 'name', name)
            const localVarPath = `/functions/{name}/logs`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a function\'s excution logs
         * @summary Get function\'s logs
         * @param {string} name 
         * @param {boolean} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerGetLogs: async (name: string, text: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('functionsControllerGetLogs', 'name', name)
            // verify required parameter 'text' is not null or undefined
            assertParamExists('functionsControllerGetLogs', 'text', text)
            const localVarPath = `/functions/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a function\'s metrics
         * @summary Get function\'s metrics
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerGetMetrics: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('functionsControllerGetMetrics', 'name', name)
            const localVarPath = `/functions/{name}/metrics`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish a new package on the registry. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
         * @summary Publish a package on the registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerPublishPackage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/functions/package`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all existing functions and manifest
         * @summary Reset all functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerReset: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update / Create / Delete functions based on the manifest, package must have been published first. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
         * @summary Set function manifest
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerSetFunction: async (body: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('functionsControllerSetFunction', 'body', body)
            const localVarPath = `/functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FunctionsApi - functional programming interface
 * @export
 */
export const FunctionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FunctionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Clear a function\'s excution logs
         * @summary Clear function\'s logs
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsControllerClearLogs(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsControllerClearLogs(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a function\'s excution logs
         * @summary Get function\'s logs
         * @param {string} name 
         * @param {boolean} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsControllerGetLogs(name: string, text: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsControllerGetLogs(name, text, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a function\'s metrics
         * @summary Get function\'s metrics
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsControllerGetMetrics(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsControllerGetMetrics(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Publish a new package on the registry. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
         * @summary Publish a package on the registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsControllerPublishPackage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsControllerPublishPackage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all existing functions and manifest
         * @summary Reset all functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsControllerReset(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsControllerReset(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update / Create / Delete functions based on the manifest, package must have been published first. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
         * @summary Set function manifest
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionsControllerSetFunction(body: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionsControllerSetFunction(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FunctionsApi - factory interface
 * @export
 */
export const FunctionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FunctionsApiFp(configuration)
    return {
        /**
         * Clear a function\'s excution logs
         * @summary Clear function\'s logs
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerClearLogs(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.functionsControllerClearLogs(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a function\'s excution logs
         * @summary Get function\'s logs
         * @param {string} name 
         * @param {boolean} text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerGetLogs(name: string, text: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.functionsControllerGetLogs(name, text, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a function\'s metrics
         * @summary Get function\'s metrics
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerGetMetrics(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.functionsControllerGetMetrics(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a new package on the registry. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
         * @summary Publish a package on the registry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerPublishPackage(options?: any): AxiosPromise<void> {
            return localVarFp.functionsControllerPublishPackage(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all existing functions and manifest
         * @summary Reset all functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerReset(options?: any): AxiosPromise<void> {
            return localVarFp.functionsControllerReset(options).then((request) => request(axios, basePath));
        },
        /**
         * Update / Create / Delete functions based on the manifest, package must have been published first. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
         * @summary Set function manifest
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionsControllerSetFunction(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.functionsControllerSetFunction(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FunctionsApi - object-oriented interface
 * @export
 * @class FunctionsApi
 * @extends {BaseAPI}
 */
export class FunctionsApi extends BaseAPI {
    /**
     * Clear a function\'s excution logs
     * @summary Clear function\'s logs
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionsApi
     */
    public functionsControllerClearLogs(name: string, options?: any) {
        return FunctionsApiFp(this.configuration).functionsControllerClearLogs(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a function\'s excution logs
     * @summary Get function\'s logs
     * @param {string} name 
     * @param {boolean} text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionsApi
     */
    public functionsControllerGetLogs(name: string, text: boolean, options?: any) {
        return FunctionsApiFp(this.configuration).functionsControllerGetLogs(name, text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a function\'s metrics
     * @summary Get function\'s metrics
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionsApi
     */
    public functionsControllerGetMetrics(name: string, options?: any) {
        return FunctionsApiFp(this.configuration).functionsControllerGetMetrics(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish a new package on the registry. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
     * @summary Publish a package on the registry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionsApi
     */
    public functionsControllerPublishPackage(options?: any) {
        return FunctionsApiFp(this.configuration).functionsControllerPublishPackage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all existing functions and manifest
     * @summary Reset all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionsApi
     */
    public functionsControllerReset(options?: any) {
        return FunctionsApiFp(this.configuration).functionsControllerReset(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update / Create / Delete functions based on the manifest, package must have been published first. NOTE: Uses of this endpoint is discouraged, please use our CLI tools instead
     * @summary Set function manifest
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionsApi
     */
    public functionsControllerSetFunction(body: object, options?: any) {
        return FunctionsApiFp(this.configuration).functionsControllerSetFunction(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
         * @summary Create group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroupDto: CreateGroupDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupDto' is not null or undefined
            assertParamExists('createGroup', 'createGroupDto', createGroupDto)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
         * @summary Delete a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get group\'s data such as members, private & public data, etc...
         * @summary Get a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
         * @summary Join a group
         * @param {string} id 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup: async (id: string, profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('joinGroup', 'id', id)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('joinGroup', 'profileId', profileId)
            const localVarPath = `/groups/{id}/join/{profileId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
         * @summary Leave a group
         * @param {string} id 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup: async (id: string, profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leaveGroup', 'id', id)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('leaveGroup', 'profileId', profileId)
            const localVarPath = `/groups/{id}/leave/{profileId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
         * @summary Set group\'s data
         * @param {string} id 
         * @param {SetGroupDataDto} setGroupDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupData: async (id: string, setGroupDataDto: SetGroupDataDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setGroupData', 'id', id)
            // verify required parameter 'setGroupDataDto' is not null or undefined
            assertParamExists('setGroupData', 'setGroupDataDto', setGroupDataDto)
            const localVarPath = `/groups/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setGroupDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
         * @summary Set group leader
         * @param {string} id 
         * @param {string} leader Group\&#39;s new leader id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupLeader: async (id: string, leader: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setGroupLeader', 'id', id)
            // verify required parameter 'leader' is not null or undefined
            assertParamExists('setGroupLeader', 'leader', leader)
            const localVarPath = `/groups/{id}/leader`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)

            if (leader !== undefined) {
                localVarQueryParameter['leader'] = leader;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
         * @summary Create group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroupDto: CreateGroupDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroupDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
         * @summary Delete a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get group\'s data such as members, private & public data, etc...
         * @summary Get a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
         * @summary Join a group
         * @param {string} id 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinGroup(id: string, profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinGroup(id, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
         * @summary Leave a group
         * @param {string} id 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveGroup(id: string, profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupLeaveResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveGroup(id, profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
         * @summary Set group\'s data
         * @param {string} id 
         * @param {SetGroupDataDto} setGroupDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGroupData(id: string, setGroupDataDto: SetGroupDataDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGroupData(id, setGroupDataDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
         * @summary Set group leader
         * @param {string} id 
         * @param {string} leader Group\&#39;s new leader id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGroupLeader(id: string, leader: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupUpdateResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGroupLeader(id, leader, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
         * @summary Create group
         * @param {CreateGroupDto} createGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupDto: CreateGroupDto, options?: any): AxiosPromise<Group> {
            return localVarFp.createGroup(createGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
         * @summary Delete a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get group\'s data such as members, private & public data, etc...
         * @summary Get a group
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(id: string, options?: any): AxiosPromise<Group> {
            return localVarFp.getGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
         * @summary Join a group
         * @param {string} id 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinGroup(id: string, profileId: string, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.joinGroup(id, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
         * @summary Leave a group
         * @param {string} id 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveGroup(id: string, profileId: string, options?: any): AxiosPromise<GroupLeaveResult> {
            return localVarFp.leaveGroup(id, profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
         * @summary Set group\'s data
         * @param {string} id 
         * @param {SetGroupDataDto} setGroupDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupData(id: string, setGroupDataDto: SetGroupDataDto, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.setGroupData(id, setGroupDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
         * @summary Set group leader
         * @param {string} id 
         * @param {string} leader Group\&#39;s new leader id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroupLeader(id: string, leader: string, options?: any): AxiosPromise<GroupUpdateResult> {
            return localVarFp.setGroupLeader(id, leader, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Create a new group based on the given informations, send an In-App notification to every members on their profile\'s channel (Notification is WIP)
     * @summary Create group
     * @param {CreateGroupDto} createGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(createGroupDto: CreateGroupDto, options?: any) {
        return GroupsApiFp(this.configuration).createGroup(createGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a group from the database, sends a notification that the group has been deleted on the group\'s channel
     * @summary Delete a group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get group\'s data such as members, private & public data, etc...
     * @summary Get a group
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(id: string, options?: any) {
        return GroupsApiFp(this.configuration).getGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allow a profile to join a group, sends a notification that the profile has joined on the group\'s channel
     * @summary Join a group
     * @param {string} id 
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public joinGroup(id: string, profileId: string, options?: any) {
        return GroupsApiFp(this.configuration).joinGroup(id, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a profile from group\'s members. Sends a notification that the profile has left on the group\'s channel
     * @summary Leave a group
     * @param {string} id 
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public leaveGroup(id: string, profileId: string, options?: any) {
        return GroupsApiFp(this.configuration).leaveGroup(id, profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set a group\'s public and private data. Sends a notification that the group\'s datas has been updated on the group\'s channel
     * @summary Set group\'s data
     * @param {string} id 
     * @param {SetGroupDataDto} setGroupDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public setGroupData(id: string, setGroupDataDto: SetGroupDataDto, options?: any) {
        return GroupsApiFp(this.configuration).setGroupData(id, setGroupDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Makes a profile the group leader. Only the current group\'s leader can perform this operation. Sends a notification that a new leader has been set on the group\'s channel
     * @summary Set group leader
     * @param {string} id 
     * @param {string} leader Group\&#39;s new leader id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public setGroupLeader(id: string, leader: string, options?: any) {
        return GroupsApiFp(this.configuration).setGroupLeader(id, leader, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a profile. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary Create a profile
         * @param {CreateProfileDto} createProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (createProfileDto: CreateProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProfileDto' is not null or undefined
            assertParamExists('createProfile', 'createProfileDto', createProfileDto)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a profile owned by a player
         * @summary Delete a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('deleteProfile', 'profileId', profileId)
            const localVarPath = `/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a profile owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary Get a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getProfile', 'profileId', profileId)
            const localVarPath = `/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all profiles owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary List all profiles owned by a player
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles: async (ownerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ownerId' is not null or undefined
            assertParamExists('listProfiles', 'ownerId', ownerId)
            const localVarPath = `/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)

            if (ownerId !== undefined) {
                localVarQueryParameter['ownerId'] = ownerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a profile. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary Create a profile
         * @param {CreateProfileDto} createProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(createProfileDto: CreateProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(createProfileDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a profile owned by a player
         * @summary Delete a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDeletedDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return a profile owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary Get a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all profiles owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary List all profiles owned by a player
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProfiles(ownerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Profile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProfiles(ownerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * Create a profile. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary Create a profile
         * @param {CreateProfileDto} createProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(createProfileDto: CreateProfileDto, options?: any): AxiosPromise<Profile> {
            return localVarFp.createProfile(createProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a profile owned by a player
         * @summary Delete a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(profileId: string, options?: any): AxiosPromise<ProfileDeletedDto> {
            return localVarFp.deleteProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a profile owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary Get a profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(profileId: string, options?: any): AxiosPromise<Profile> {
            return localVarFp.getProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all profiles owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
         * @summary List all profiles owned by a player
         * @param {string} ownerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfiles(ownerId: string, options?: any): AxiosPromise<Array<Profile>> {
            return localVarFp.listProfiles(ownerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI {
    /**
     * Create a profile. Note: Currencies, Stats, etc... are not returned by this endpoint
     * @summary Create a profile
     * @param {CreateProfileDto} createProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public createProfile(createProfileDto: CreateProfileDto, options?: any) {
        return ProfilesApiFp(this.configuration).createProfile(createProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a profile owned by a player
     * @summary Delete a profile
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public deleteProfile(profileId: string, options?: any) {
        return ProfilesApiFp(this.configuration).deleteProfile(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a profile owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
     * @summary Get a profile
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfile(profileId: string, options?: any) {
        return ProfilesApiFp(this.configuration).getProfile(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all profiles owned by a player. Note: Currencies, Stats, etc... are not returned by this endpoint
     * @summary List all profiles owned by a player
     * @param {string} ownerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public listProfiles(ownerId: string, options?: any) {
        return ProfilesApiFp(this.configuration).listProfiles(ownerId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all stats (public, private, internal) of the requested profile
         * @summary Get profile\'s stats
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getStats', 'profileId', profileId)
            const localVarPath = `/stats/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
         * @summary Set profile\'s stats
         * @param {string} profileId 
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStats: async (profileId: string, updateStatsDto: UpdateStatsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('setStats', 'profileId', profileId)
            // verify required parameter 'updateStatsDto' is not null or undefined
            assertParamExists('setStats', 'updateStatsDto', updateStatsDto)
            const localVarPath = `/stats/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
         * @summary Update profile\'s stats
         * @param {string} profileId 
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStats: async (profileId: string, updateStatsDto: UpdateStatsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('updateStats', 'profileId', profileId)
            // verify required parameter 'updateStatsDto' is not null or undefined
            assertParamExists('updateStats', 'updateStatsDto', updateStatsDto)
            const localVarPath = `/stats/profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AppSecret required
            await setApiKeyToObject(localVarHeaderParameter, "AppSecret", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return all stats (public, private, internal) of the requested profile
         * @summary Get profile\'s stats
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(profileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
         * @summary Set profile\'s stats
         * @param {string} profileId 
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStats(profileId: string, updateStatsDto: UpdateStatsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStats(profileId, updateStatsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
         * @summary Update profile\'s stats
         * @param {string} profileId 
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStats(profileId: string, updateStatsDto: UpdateStatsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStats(profileId, updateStatsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Return all stats (public, private, internal) of the requested profile
         * @summary Get profile\'s stats
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(profileId: string, options?: any): AxiosPromise<Stats> {
            return localVarFp.getStats(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
         * @summary Set profile\'s stats
         * @param {string} profileId 
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStats(profileId: string, updateStatsDto: UpdateStatsDto, options?: any): AxiosPromise<Stats> {
            return localVarFp.setStats(profileId, updateStatsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
         * @summary Update profile\'s stats
         * @param {string} profileId 
         * @param {UpdateStatsDto} updateStatsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStats(profileId: string, updateStatsDto: UpdateStatsDto, options?: any): AxiosPromise<Stats> {
            return localVarFp.updateStats(profileId, updateStatsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     * Return all stats (public, private, internal) of the requested profile
     * @summary Get profile\'s stats
     * @param {string} profileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public getStats(profileId: string, options?: any) {
        return StatsApiFp(this.configuration).getStats(profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set stats (public, private) of the requested profile. This operation replace the whole stats object, use it carefully (or use Update Stats)
     * @summary Set profile\'s stats
     * @param {string} profileId 
     * @param {UpdateStatsDto} updateStatsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public setStats(profileId: string, updateStatsDto: UpdateStatsDto, options?: any) {
        return StatsApiFp(this.configuration).setStats(profileId, updateStatsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update stats (public, private) of the requested profile. This operation replace only the specified fields in the request, other fields will not be updated.
     * @summary Update profile\'s stats
     * @param {string} profileId 
     * @param {UpdateStatsDto} updateStatsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public updateStats(profileId: string, updateStatsDto: UpdateStatsDto, options?: any) {
        return StatsApiFp(this.configuration).updateStats(profileId, updateStatsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


